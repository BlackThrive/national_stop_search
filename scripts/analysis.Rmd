---
title: "Untitled"
author: "Jolyon Miles-Wilson"
date: "07/01/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Packages

```{r}
library(tidyverse)
library(gmodels) # CrossTable()
library(epitools) # riskratio
```

```{r}

rr_from_df <- function(df, name){
  # function takes dfs made earlier, transforms in matrices, and creates risk
  # ratios and associated confidence intervals
  # 'name' is the name of the indicator
  mat <- matrix(c(df[2,2],
                  df[2,1],
                  df[1,2],
                  df[1,1]), 2, 2)
  df_out <- data.frame("indicator" = name,
                     "rr" = riskratio(mat)[["measure"]][2,1],
                     "ci_low" = riskratio(mat)[["measure"]][2,2],
                     "ci_upp" = riskratio(mat)[["measure"]][2,3])
  return(df_out)
}
```


# Data

```{r}
data <- read.csv("../data/national_dataset_with_forces.csv")

data_no_ni <- subset(data, country != "Northern Ireland") # don't consider NI because don't currently have pop data

#save(df, file = "../data/national_dataset_with_forces.Rdata")
```

```{r}
population_ests <- read.csv("../data/la_pop_estimates_2021_2.csv")
population_ests <- population_ests %>%
  mutate(across(ncol(population_ests)), na_if(., "!")) %>%
  mutate(across(ncol(population_ests)), na_if(., "-")) %>%
  mutate(across(ncol(population_ests)), na_if(., "~"))
```

```{r}
df <- data_no_ni
# collapse ethnicity 
df$self_defined_ethnicity <- as.factor(df$self_defined_ethnicity)
df$self_defined_ethnicity <- fct_collapse(df$self_defined_ethnicity,
                                          Asian = c("Asian/Asian British - Any other Asian background",
                                          "Asian/Asian British - Bangladeshi",
                                          "Asian/Asian British - Chinese",
                                          "Asian/Asian British - Indian",
                                          "Asian/Asian British - Pakistani"),
                                          Black = c("Black/African/Caribbean/Black British - African",
                                          "Black/African/Caribbean/Black British - Any other Black/African/Caribbean background",
                                          "Black/African/Caribbean/Black British - Caribbean"),
                                          Mixed = c("Mixed/Multiple ethnic groups - Any other Mixed/Multiple ethnic background",
                                          "Mixed/Multiple ethnic groups - White and Asian",
                                          "Mixed/Multiple ethnic groups - White and Black African",
                                          "Mixed/Multiple ethnic groups - White and Black Caribbean"),
                                          Other = c("Other ethnic group - Any other ethnic group",
                                          "Other ethnic group - Not stated"),
                                          White = c("White - Any other White background",
                                          "White - English/Welsh/Scottish/Northern Irish/British",
                                          "White - Irish")
)

subset_df <- subset(df, self_defined_ethnicity == "White" | self_defined_ethnicity == "Black")
subset_df$self_defined_ethnicity <- factor(subset_df$self_defined_ethnicity, levels = c("White", "Black"))
subset_df <- subset_df %>%
  rename(
    ethnicity = self_defined_ethnicity
  )

# fix misspelling of Rhondda Cynon Taff
subset_df$la_name[which(subset_df$la_name == "Rhondda Cynon Taf")] <- "Rhondda Cynon Taff"
```

```{r}


```

# by LA 

```{r}
las <- unique(subset_df$la_name) # get la names from the dataset
all_results <- data.frame() # initialise
all_mats <- matrix(data = c(0,0,0,0), ncol = 2, nrow = 2)
all_dfs <- data.frame()

for(i in 1:length(las)){
  results_df <- data.frame() # initialise
  
  # get data for la
  la <- unique(subset_df[which(subset_df$la_name == las[i]), "la_name"])
  county <- unique(subset_df[which(subset_df$la_name == las[i]), "county"])
  region <- unique(subset_df[which(subset_df$la_name == las[i]), "region"])
  country <- unique(subset_df[which(subset_df$la_name == las[i]), "country"])
  force <- unique(subset_df[which(subset_df$la_name == las[i]), "force"])
  proportion_months_acquired <- unique(subset_df[which(subset_df$la_name == las[i]), "proportion_months_acquired"])
  
  temp_df <- subset_df %>% # subset to la
    subset(., la_name == la) 
  
  if(length(unique(temp_df$ethnicity)) == 2){ # check that there are stops for both white and black individuals
    
    # collect stats
    temp_df <- temp_df %>%
    group_by(ethnicity) %>%
    summarise(
      stopped = n()
    ) %>%
    mutate(
      pop = c(as.numeric(population_ests[which(population_ests$LAD == la), "White"]), 
              as.numeric(population_ests[which(population_ests$LAD == la), "Black"])),
      percentage = 100 * (stopped/pop),
      not_stopped = pop - stopped
    ) %>%
    as.data.frame()
  
    row.names(temp_df) <- temp_df$ethnicity
    
    black <- data.frame("Black" = c("stopped" = temp_df["Black", "stopped"], "not_stopped" = temp_df["Black", "not_stopped"]))
    
    white <- data.frame("White" = c("stopped" = temp_df["White", "stopped"], "not_stopped" = temp_df["White", "not_stopped"]))
    
    bw_mat <- as.matrix(cbind(black, white)) # matrix for crosstable
    bw_df <- as.data.frame(bw_mat) # df for custom rr function
    
    
    if(sum(is.na(bw_mat)) == 0){ # if there are figures for all cells, run stats
      xtab <- CrossTable(bw_mat, chisq = T, fisher = T, expected = T)
      rr <- rr_from_df(bw_df, "Stop & Search")
      results_df <- data.frame("la" = la,
                           "county" = county,
                           "region" = region,
                           "country" = country,
                           "force" = force,
                           "or" = xtab[["fisher.ts"]][["estimate"]][["odds ratio"]], 
                           "or_ci_low" = xtab[["fisher.ts"]][["conf.int"]][1],
                           "or_ci_upp" = xtab[["fisher.ts"]][["conf.int"]][2],
                           "rr" = rr$rr,
                           "rr_ci_low" = rr$ci_low,
                           "rr_ci_upp" = rr$ci_upp,
                           "proportion_months_acquired" = proportion_months_acquired)
      
     all_mats <- all_mats + bw_mat
      
    }

  }
  # if there is not data for both black and white, and/or there are missing values
  else{
    results_df <- data.frame("la" = la,
                         "county" = county,
                         "region" = region,
                         "country" = country,
                         "force" = force,
                         "or" = NA, 
                         "or_ci_low" = NA,
                         "or_ci_upp" = NA,
                         "rr" = NA,
                         "rr_ci_low" = NA,
                         "rr_ci_upp" = NA,
                         "proportion_months_acquired" = proportion_months_acquired)
  }

  
  all_results <- rbind(all_results, results_df) # add results to all results
  all_dfs <- as.data.frame(all_mats)
  cat("\014")
  print(paste0(i, " of ", length(las), " complete (", round(100 * (i / length(las)),2 ), "%)"))
}

all_results <- all_results[order(all_results$rr, decreasing = T),]
la_results <- all_results
```

# national

```{r}
xtab_all_las <- CrossTable(all_mats, chisq = T, fisher = T, expected = T)
rr_all_las <- rr_from_df(all_dfs, "stop_search_all")
```

```{r}
# get all population estimates that can be used

usable_las <- unique(all_results$la)

pops <- data.frame("white" = as.numeric(population_ests[which(c(population_ests$LAD %in% usable_las)), "White"]), "black" = as.numeric(population_ests[which(c(population_ests$LAD %in% usable_las)), "Black"]))

pops <- pops[which(rowSums(is.na(pops)) == 0),] 

# sum all populations
pops_sums <- data.frame("white" = sum(pops$white), "black" = sum(pops$black))
```
```{r}
# add population estimate to actual df
for(i in 1:nrow(subset_df)){
  subset_df$white_pop_estimate[i] <- population_ests[which(population_ests$LAD == subset_df$la_name[i]), "White"]
  subset_df$black_pop_estimate[i] <- population_ests[which(population_ests$LAD == subset_df$la_name[i]), "Black"]
}
```


# by force 

```{r}
las <- unique(subset_df$la_name) # get la names from the dataset
all_results <- data.frame() # initialise
all_mats <- matrix(data = c(0,0,0,0), ncol = 2, nrow = 2)
all_dfs <- data.frame()


# collect stats
temp_df <- subset_df %>%
  group_by(force, la_name, ethnicity) %>%
  summarise(
    stopped = n()
  )

population_ests_subset <- population_ests[,c("LAD","White","Black")] %>%
  rename(
    la_name = LAD
  )

test <- merge(population_ests_subset, temp_df, by = "la_name")
test$White <- as.numeric(test$White)
test$Black <- as.numeric(test$Black)

test <- test[-c(which(test$la_name == "Cambridge")),] # remove cambridge because it is included in south cambridgeshire stats

test_2 <- test %>%
  pivot_wider(names_from = ethnicity, values_from = stopped, names_prefix = "stopped_") %>%
  rename(
    white_pop = White,
    black_pop = Black,
    stopped_white = stopped_White,
    stopped_black = stopped_Black
  ) %>%
  drop_na() %>%
  mutate(
    not_stopped_black = black_pop - stopped_black,
    not_stopped_white = white_pop - stopped_white
    )

# calculate how many las from each force ahve  been used to calculate the stat
force_las <- test %>%
  group_by(force) %>%
  summarise(
    count = length(unique(la_name))
  )

force_las_2 <- test_2 %>%
  group_by(force) %>%
  summarise(
    count_2 = length(unique(la_name))
  )

force_prop_las <- merge(force_las, force_las_2, by = "force") %>%
  mutate(
    prop_las = count_2 / count # calculate proportion
  )


```

```{r}
forces <- unique(test_2$force) # get la names from the dataset
missing_forces <- unique(subset_df$force[-c(which(subset_df$force %in% forces))])
all_results <- data.frame() # initialise
all_mats <- matrix(data = c(0,0,0,0), ncol = 2, nrow = 2)
all_dfs <- data.frame()

temp_df <- test_2 %>% # subset to la
  group_by(force) %>%
  summarise(
    stopped_black = sum(stopped_black),
    stopped_white = sum(stopped_white),
    not_stopped_black = sum(not_stopped_black),
    not_stopped_white = sum(not_stopped_white)
  )
  
for(i in 1:nrow(temp_df)){
  results_df <- data.frame() # initialise
  
  # get data for la
  # la <- unique(subset_df[which(test_2$force == forces[i]), "la_name"])
  # county <- unique(subset_df[which(test_2$force == forces[i]), "county"])
  # region <- unique(subset_df[which(test_2$force == forces[i]), "region"])
  # country <- unique(subset_df[which(test_2$force == forces[i]), "country"])
  force <- temp_df$force[i]
  
  black <- data.frame("Black" = c("stopped" = temp_df$stopped_black[i], "not_stopped" = temp_df$not_stopped_black[i]))
  
  white <- data.frame("White" = c("stopped" = temp_df$stopped_white[i], "not_stopped" = temp_df$not_stopped_white[i]))
  
  bw_mat <- as.matrix(cbind(black, white)) # matrix for crosstable
  
  bw_df <- as.data.frame(bw_mat) # df for custom rr function
    
  xtab <- CrossTable(bw_mat, chisq = T, fisher = T, expected = T)
  rr <- rr_from_df(bw_df, "Stop & Search")
  
  results_df <- data.frame(
                       "force" = force,
                       "or" = xtab[["fisher.ts"]][["estimate"]][["odds ratio"]], 
                       "or_ci_low" = xtab[["fisher.ts"]][["conf.int"]][1],
                       "or_ci_upp" = xtab[["fisher.ts"]][["conf.int"]][2],
                       "rr" = rr$rr,
                       "rr_ci_low" = rr$ci_low,
                       "rr_ci_upp" = rr$ci_upp
  )
  
  all_results <- rbind(all_results, results_df) # add results to all results
  cat("\014")
  print(paste0(i, " of ", length(forces), " complete (", round(100 * (i / length(forces)),2 ), "%)"))
}

all_results <- merge(all_results, force_prop_las[,c(1,4)], by = "force") # add proprotion las accoutned for to results table
all_results <- all_results[order(all_results$rr, decreasing = T),] # order table biggest to smallest
forces_results <- all_results
```
# plot

```{r fig.height=10}
library(plotly)
library(RColorBrewer)
mycolors <- colorRampPalette(brewer.pal(8, "Set2"))(45)

plot_data <- all_results[order(all_results$or),] # order smallest to biggest
plot_data$la <- factor(plot_data$la, levels = plot_data$la) 

plot_data <- plot_data[!is.na(plot_data$or),]

p <- ggplot(plot_data, aes(la, or, colour = force)) +
  geom_point() +
  geom_errorbar(aes(ymin = or_ci_low, ymax = or_ci_upp)) +
  coord_flip() +
  theme_bw() +
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        panel.grid.major.y = element_blank()) +
  scale_colour_manual(values = mycolors) +
  scale_y_continuous(breaks = c(1,seq(5,60,5))) 

q <- plotly::ggplotly(p)
q
```

# rr

```{r}
library(plotly)
library(RColorBrewer)
mycolors <- colorRampPalette(brewer.pal(8, "Set2"))(45)

plot_data <- all_results[order(all_results$rr),] # order smallest to biggest
plot_data$la <- factor(plot_data$la, levels = plot_data$la) 

plot_data <- plot_data[!is.na(plot_data$rr),]

p <- ggplot(plot_data, aes(la, rr, colour = force)) +
  geom_point() +
  geom_errorbar(aes(ymin = rr_ci_low, ymax = rr_ci_upp)) +
  coord_flip() +
  theme_bw() +
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        panel.grid.major.y = element_blank()) +
  scale_colour_manual(values = mycolors) +
  scale_y_continuous(breaks = c(0,1,seq(5,60,5))) +
  scale_x_discrete(expand = c(0,10))

q <- plotly::ggplotly(p)
q
```

```{r}
nrow(all_results[-c(which(all_results$rr_ci_low < 1)),])
```

```{r}
library(htmlwidgets)
saveWidget(q, "plot.html", selfcontained = F, libdir = "lib")
zip("plot.zip", c("plot.html", "lib"))
```

```{r}
kut <- subset(subset_df, la_name == "Kingston upon Thames")

temp_df <- kut %>%
group_by(ethnicity) %>%
summarise(
  stopped = n()
) %>%
mutate(
  pop = c(as.numeric(population_ests[which(population_ests$LAD == "Kingston upon Thames"), "White"]), 
          as.numeric(population_ests[which(population_ests$LAD == "Kingston upon Thames"), "Black"])),
  percentage = 100 * (stopped/pop),
  not_stopped = pop - stopped
) %>%
as.data.frame()


row.names(temp_df) <- temp_df$ethnicity
black <- data.frame("Black" = c("stopped" = temp_df["Black", "stopped"], "not_stopped" = temp_df["Black", "not_stopped"]))

white <- data.frame("White" = c("stopped" = temp_df["White", "stopped"], "not_stopped" = temp_df["White", "not_stopped"]))

bw_mat <- as.matrix(cbind(black, white)) # matrix for crosstable
bw_df <- as.data.frame(bw_mat) # df for custom rr function

CrossTable(bw_mat, chisq = T, fisher = T, expected = T)

```

```{r}
lambeth <- subset(subset_df, la_name == "Lambeth")

temp_df <- lambeth %>%
group_by(ethnicity) %>%
summarise(
  stopped = n()
) %>%
mutate(
  pop = c(as.numeric(population_ests[which(population_ests$LAD == "Lambeth"), "White"]), 
          as.numeric(population_ests[which(population_ests$LAD == "Lambeth"), "Black"])),
  percentage = 100 * (stopped/pop),
  not_stopped = pop - stopped
) %>%
as.data.frame()


row.names(temp_df) <- temp_df$ethnicity
black <- data.frame("Black" = c("stopped" = temp_df["Black", "stopped"], "not_stopped" = temp_df["Black", "not_stopped"]))

white <- data.frame("White" = c("stopped" = temp_df["White", "stopped"], "not_stopped" = temp_df["White", "not_stopped"]))

bw_mat <- as.matrix(cbind(black, white)) # matrix for crosstable
bw_df <- as.data.frame(bw_mat) # df for custom rr function

CrossTable(bw_mat, chisq = T, fisher = T, expected = T)

```

```{r}
Gedling <- subset(subset_df, la_name == "Gedling")

temp_df <- Gedling %>%
group_by(ethnicity) %>%
summarise(
  stopped = n()
) %>%
mutate(
  pop = c(as.numeric(population_ests[which(population_ests$LAD == "Gedling"), "White"]), 
          as.numeric(population_ests[which(population_ests$LAD == "Gedling"), "Black"])),
  percentage = 100 * (stopped/pop),
  not_stopped = pop - stopped
) %>%
as.data.frame()


row.names(temp_df) <- temp_df$ethnicity
black <- data.frame("Black" = c("stopped" = temp_df["Black", "stopped"], "not_stopped" = temp_df["Black", "not_stopped"]))

white <- data.frame("White" = c("stopped" = temp_df["White", "stopped"], "not_stopped" = temp_df["White", "not_stopped"]))

bw_mat <- as.matrix(cbind(black, white)) # matrix for crosstable
bw_df <- as.data.frame(bw_mat) # df for custom rr function

CrossTable(bw_mat, chisq = T, fisher = T, expected = T)

```

# Outcome analysis

```{r}
subset_df$nfa <- ifelse(subset_df$outcome_object.id == "bu-no-further-action", 1, 0)

subset_df$nfa <- factor(subset_df$nfa, levels = c("0","1"))
levels(subset_df$nfa)
subset_df$gender <- factor(subset_df$gender, levels = c("Female","Male", "Other", NA))

mod <- glm(nfa ~ gender * ethnicity, subset_df, family = "binomial")
summary(mod)
```

```{r}
library(emmeans)
ems <- emmeans(mod, specs = c("ethnicity","gender"))
ems <- emmeans(mod, specs = "ethnicity", by = "gender")
ems <- emmeans(mod, specs = "gender", by = "ethnicity")

contrast(ems)
```

# mixed

```{r}
library(lme4)

mixed_mod <- glmer(nfa ~ gender * ethnicity + (ethnicity|force), subset_df, family = "binomial")
summary(mixed_mod)

```

```{r}
plot(ranef(mixed_mod))
ranefs <- ranef(mixed_mod)$force

ggplot(ranefs, aes(rownames(ranefs), ethnicityBlack)) +
  geom_point() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))
```

To run chisquare analyses controlling for covaraites, we'd need to bin count tables wihtin levels of covariates. i.e. do a contingency table for each level of age range, gender, etc. 

# Hotspot test

```{r}
lambeth <- subset(subset_df, la_name == "Lambeth")

lambeth_freq <- lambeth[,c("ethnicity","location.street.name","location.longitude","location.latitude")] %>%
  group_by(location.street.name, ethnicity) %>%
  # summarise(
  #   n = n(),
  #   long = location.longitude,
  #   lat = location.latitude
  # ) %>%
  mutate(
    n = n(),
  )

lambeth_freq <- lambeth_freq[order(lambeth_freq$ethnicity, lambeth_freq$n, decreasing = T),]
lambeth_freq <- lambeth_freq[!duplicated(lambeth_freq),]

lambeth_freq_2 <- lambeth_freq %>%
  group_by(location.street.name) %>%
  mutate(
    proportion_stops = n / sum(n)
  )

lambeth_coords <- lambeth[,c("ethnicity","location.longitude","location.latitude")]
```

```{r}
library(leaflet)
lambeth_coords_black <- subset(lambeth_freq, ethnicity == "Black")
lambeth_coords_white <- subset(lambeth_freq, ethnicity == "White")

lambeth_coords_white[,3] <- as.numeric(unlist(lambeth_coords_white[,3]))

cols <- colorFactor(palette = c("orange","black"),lambeth_coords$ethnicity)

lambeth_boundary <- as.matrix(ordered_coords[["Lambeth"]][["coords"]][[1]])
# this accounts for frequency (technically). Ideally would improve this with a more sensitive scale
leaflet() %>%
  addCircleMarkers(data = lambeth_coords, lng = ~location.longitude, lat = ~location.latitude, color = ~cols(ethnicity), radius = 1, opacity = 0.2) %>%
  addTiles() %>%
  addLegend(pal = cols, values = lambeth_coords$ethnicity)

# this just plots the unique places that blakc and white people are stopped
# shows that black people are stopped everywhere, whereas there are fewer unique locatoins where white people are stopped
leaflet() %>%
  addCircleMarkers(data = lambeth_freq, lng = ~location.longitude, lat = ~location.latitude, color = ~cols(ethnicity), radius = 1, opacity = 0.7) %>%
  addPolylines(lng = lambeth_boundary[,1], lat = lambeth_boundary[,2], color = "red", weight = 3) %>%
  addTiles() %>%
  addLegend(pal = cols, values = lambeth_freq$ethnicity) 
```


# time of day

```{r}
evening <- subset(lambeth, time > "18:00:00" & time <= "23:59:59" | time >= "00:00:00" & time < "06:00:00")
day <- subset(lambeth, time >= "06:00:00" & time <= "18:00:00")

day_df <- day %>%
  group_by(ethnicity) %>%
  summarise(
    stopped = n()
  ) %>%
  mutate(
    pop = c(as.numeric(population_ests[which(population_ests$LAD == "Lambeth"), "White"]), 
            as.numeric(population_ests[which(population_ests$LAD == "Lambeth"), "Black"])),
    percentage = 100 * (stopped/pop),
    not_stopped = pop - stopped
  ) %>%
  as.data.frame()


row.names(day_df) <- day_df$ethnicity
black <- data.frame("Black" = c("stopped" = day_df["Black", "stopped"], "not_stopped" = day_df["Black", "not_stopped"]))

white <- data.frame("White" = c("stopped" = day_df["White", "stopped"], "not_stopped" = day_df["White", "not_stopped"]))

day_bw_mat <- as.matrix(cbind(black, white)) # matrix for crosstable
day_bw_df <- as.data.frame(bw_mat) # df for custom rr function

evening_df <- evening %>%
  group_by(ethnicity) %>%
  summarise(
    stopped = n()
  ) %>%
  mutate(
    pop = c(as.numeric(population_ests[which(population_ests$LAD == "Lambeth"), "White"]), 
            as.numeric(population_ests[which(population_ests$LAD == "Lambeth"), "Black"])),
    percentage = 100 * (stopped/pop),
    not_stopped = pop - stopped
  ) %>%
  as.data.frame()


row.names(evening_df) <- evening_df$ethnicity
black <- data.frame("Black" = c("stopped" = evening_df["Black", "stopped"], "not_stopped" = evening_df["Black", "not_stopped"]))

white <- data.frame("White" = c("stopped" = evening_df["White", "stopped"], "not_stopped" = evening_df["White", "not_stopped"]))

evening_bw_mat <- as.matrix(cbind(black, white)) # matrix for crosstable
evening_bw_df <- as.data.frame(bw_mat) # df for custom rr function

xtab_day <- CrossTable(day_bw_mat, chisq = T, fisher = T, expected = T)

xtab_evening <- CrossTable(evening_bw_mat, chisq = T, fisher = T, expected = T)

```

```{r}
plot_data <- data.frame(
                        "time" = c("day","evening"),
                        "or" = c(xtab_day[["fisher.ts"]][["estimate"]],
                                 xtab_evening[["fisher.ts"]][["estimate"]]),
                        "ci_low" = c(xtab_day[["fisher.ts"]][["conf.int"]][1],
                                     xtab_evening[["fisher.ts"]][["conf.int"]][1]),
                        "ci_upp" = c(xtab_day[["fisher.ts"]][["conf.int"]][2],
                                     xtab_evening[["fisher.ts"]][["conf.int"]][2])
                        )
ggplot(plot_data, aes(time, or)) +
  geom_point() +
  geom_errorbar(aes(ymin = ci_low, ymax = ci_upp), width = 0.2) +
  scale_y_continuous(limits = c(0,8), breaks = seq(0,8,1)) + 
  geom_hline(yintercept = 1) +
  coord_flip() +
  theme_bw() +
  ggtitle("Rate of stops of Black people compared to White people in Lambeth \nduring the day (06:00 - 18:00) and during the evening (18:00 - 06:00)")

day_df$time <- "day"
evening_df$time <- "evening"
plot_data_2 <- rbind(day_df,evening_df)

ggplot(plot_data_2, aes(time, percentage, fill = ethnicity)) +
  geom_col(position = "dodge") +
  theme_bw() +
  ggtitle("Percentage of Black and White populations in Lambeth stopped \nduring the day (06:00 - 18:00) and during the evening (18:00 - 06:00)")
```


```{r}
evening <- subset(lambeth, time > times("18:00:00") & time <= times("23:59:59") | time >= times("00:00:00") & time < times("06:00:00"))
day <- subset(lambeth, time >= times("06:00:00") & time <= times("18:00:00"))

evening_coords <- evening[,c("ethnicity","location.street.name","location.longitude","location.latitude")]
day_coords <- day[,c("ethnicity","location.street.name","location.longitude","location.latitude")]

nrow(evening) + nrow(day) # check division accounts for all cases

eve_cols <- colorFactor(palette = c("orange","black"), evening_coords$ethnicity)
day_cols <- colorFactor(palette = c("orange","black"), day_coords$ethnicity)




```

```{r}
leaflet() %>%
  addCircleMarkers(data = evening_coords, lng = ~location.longitude, lat = ~location.latitude, color = ~cols(ethnicity), radius = 1, opacity = 0.2) %>%
  addTiles() %>%
  addLegend(pal = eve_cols, values = evening_coords$ethnicity)

```


```{r}
leaflet() %>%
  addCircleMarkers(data = day_coords, lng = ~location.longitude, lat = ~location.latitude, color = ~cols(ethnicity), radius = 1, opacity = 0.2) %>%
  addTiles() %>%
  addLegend(pal = eve_cols, values = day_coords$ethnicity)
```

```{r}
library(leaflet.extras)

leaflet() %>%
  addHeatmap(data = evening_coords[which(evening_coords$ethnicity == "Black"),], lng = ~location.longitude, lat = ~location.latitude, radius = 8, gradient = "Greys", blur = 14) %>% # color = ~cols(ethnicity), radius = 1, opacity = 0.2) %>%
  addHeatmap(data = evening_coords[which(evening_coords$ethnicity == "White"),], lng = ~location.longitude, lat = ~location.latitude, radius = 8, gradient = "Oranges", blur = 14) %>% # color = ~cols(ethnicity), radius = 1, opacity = 0.2) %>%

  addTiles() 
# %>%
#   addLegend(pal = eve_cols, values = evening_coords$ethnicity)

```

possible to do a subtraction to show main differences for day/night or black/white?

```{r}
leaflet() %>%
  addHeatmap(data = day_coords[which(day_coords$ethnicity == "Black"),], lng = ~location.longitude, lat = ~location.latitude, radius = 8, gradient = "Greys", blur = 14) %>% # color = ~cols(ethnicity), radius = 1, opacity = 0.2) %>%
  addHeatmap(data = day_coords[which(day_coords$ethnicity == "White"),], lng = ~location.longitude, lat = ~location.latitude, radius = 8, gradient = "Oranges", blur = 14) %>% # color = ~cols(ethnicity), radius = 1, opacity = 0.2) %>%

  addTiles() 
```


# object of search > outcome

```{r}
freq <- lambeth %>%
  group_by(ethnicity, object_of_search) %>%
  summarise(
    n = n ()
  ) %>% 
  mutate(
    percentage = 100 * (n / sum(n))
  )

freq_2 <- lambeth %>%
  group_by(ethnicity, object_of_search, outcome) %>%
  summarise(
    n = n ()
  ) %>% 
  mutate(
    percentage = 100 * (n / sum(n))
  )
```

```{r fig.height=10, fig.width=5}
ggplot(freq_2, aes(outcome,percentage, fill = ethnicity)) +
  facet_grid(rows = vars(object_of_search)) +
  geom_col(position = "dodge") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        strip.text.y = element_text(angle = 0)) +
  scale_y_continuous(breaks = seq(0,100,10))
```

above graph shows the percentage of stops of individuals of each ethcnitiy stopped for a particiular reason ending in each outcome.
e.g. close to 90% of Blacck indviduals stopped for "Anything threatening ..." recieved a "no further action disposal".

more or less same rate of outcomes for black and white people. suggests that whilst black people are stopped at a higher rate than white people, the type of outcome that follows the object of the search is more or less the same. evidence against greater criminality argument.

# dash attempt. should see my earlier attempts on how to do this

```{r}
library(dash)
library(dashCoreComponents)
library(dplyr)
library(plotly)

available_objects <- unique(freq$object_of_search)

option_indicator <- lapply(
  available_objects, function(available_object){
  list(label = available_object,
       value = available_object)
  }
)

app <- dash_app()

app %>% set_layout(
    div(
    dash::dccDropdown(
      id = 'facet',
      options = option_indicator,
      value = 'Anything to threaten or harm anyone'
    ),
    dash::dccGraph(id = 'graph')
    )
)

app %>% add_callback(
  output('graph','figure'),
  input('facet', 'value'),
  function(facet){
    df <- subset(freq_2, object_of_search == facet)
    
    outcomes <- df$outcome
    black <- df[which(df$ethnicity == "Black"),"percentage"]
    white <- df[which(df$ethnicity == "White"),"percentage"]

    to_plot <- 
      list(
        x = df$outcome,
        y = df$percentage
      )

    input_data <- list(
      c(
        data,
        list(
          opacity = 0.7,
          mode = 'markers',
          marker = list(
            size = 15,
            line = list(width = 0.5, color = 'black')
          )
        )
      )
    )

    list(
      data = input_data,
      layout = list(
        xaxis = list('title' = "Outcome"),
        yaxis = list('title' = "Percentage"),
        hovermode = "closest"
      )
    )
  }
)



app %>% run_app()
```

